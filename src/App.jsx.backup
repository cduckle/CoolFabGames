import React, { useState, useRef, useEffect, useMemo } from 'react';
import { Canvas } from '@react-three/fiber';
import { OrbitControls, Edges } from '@react-three/drei';
import * as THREE from 'three';
import { mask, pattern } from 'framer-motion/client';
import { MOSFET_GOAL_RECTS } from './mosfetGoal.js';
import Confetti from 'react-confetti';


// Level definitions
const LEVELS = {
  introduction: {
    name: 'Introduction',
    description: 'Welcome to Cool Fab Games',
    details: 'Learn about nano-fabrication and the basic building blocks of digital devices.',
    goalRects: [] // No goal for introduction level
  },
  
  waveguide: {
    name: 'Waveguide',
    description: 'Optical Waveguide',
    details: 'Guides light through a narrow channel for photonic circuits.',
    goalRects: [
      // Simple straight waveguide
      { x: 0.2, y: 0.45, w: 0.6, h: 0.1, l: 1, color: '#8ac6d1' },
      { x: 0.2, y: 0.45, w: 0.6, h: 0.1, l: 2, color: '#f6d186' }
    ]
  },
  spiral: {
    name: 'Spiral Waveguide',
    description: 'Spiral Optical Waveguide',
    details: 'A compact spiral design for delay lines and filters.',
    goalRects: [
      // Spiral pattern
      { x: 0.3, y: 0.3, w: 0.4, h: 0.05, l: 1, color: '#8ac6d1' },
      { x: 0.3, y: 0.65, w: 0.4, h: 0.05, l: 1, color: '#8ac6d1' },
      { x: 0.3, y: 0.3, w: 0.05, h: 0.4, l: 1, color: '#8ac6d1' },
      { x: 0.65, y: 0.3, w: 0.05, h: 0.4, l: 1, color: '#8ac6d1' },
      { x: 0.35, y: 0.4, w: 0.25, h: 0.05, l: 1, color: '#8ac6d1' },
      { x: 0.35, y: 0.55, w: 0.25, h: 0.05, l: 1, color: '#8ac6d1' },
      { x: 0.35, y: 0.4, w: 0.05, h: 0.2, l: 1, color: '#8ac6d1' },
      { x: 0.55, y: 0.4, w: 0.05, h: 0.2, l: 1, color: '#8ac6d1' },
    ]
  },
  splitter: {
    name: 'Y-Splitter',
    description: 'Optical Power Splitter',
    details: 'Splits one optical signal into two equal parts.',
    goalRects: [
      // Input waveguide
      { x: 0.1, y: 0.45, w: 0.3, h: 0.1, l: 1, color: '#8ac6d1' },
      // Split section
      { x: 0.4, y: 0.4, w: 0.2, h: 0.2, l: 1, color: '#8ac6d1' },
      // Output waveguides
      { x: 0.6, y: 0.3, w: 0.3, h: 0.1, l: 1, color: '#8ac6d1' },
      { x: 0.6, y: 0.6, w: 0.3, h: 0.1, l: 1, color: '#8ac6d1' }
    ]
  },
  coupler: {
    name: 'Directional Coupler',
    description: 'Optical Directional Coupler',
    details: 'Couples light between two parallel waveguides.',
    goalRects: [
      // Two parallel waveguides
      { x: 0.1, y: 0.35, w: 0.8, h: 0.1, l: 1, color: '#8ac6d1' },
      { x: 0.1, y: 0.55, w: 0.8, h: 0.1, l: 1, color: '#8ac6d1' },
      // Coupling region (closer spacing)
      { x: 0.4, y: 0.46, w: 0.2, h: 0.08, l: 1, color: '#8ac6d1' }
    ]
  },
    mosfet: {
    name: 'MOSFET',
    description: 'Metal-Oxide Semiconductor Field Effect Transistor',
    details: 'Modern chips have billions of these small electronic switches.',
    goalRects: MOSFET_GOAL_RECTS
  },
};

function LevelSelect({ onSelectLevel }) {
  return (
    <div style={{
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      justifyContent: 'center',
      height: '100vh',
      width: '100vw',
      background: '#f0f0f0'
    }}>
      <h1 style={{ marginBottom: '2rem' }}>Cool-Fab-Games</h1>
      <div style={{
        display: 'grid',
        gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))',
        gap: '1rem',
        maxWidth: '1200px',
        padding: '1rem'
      }}>
        {Object.entries(LEVELS).map(([key, level]) => (
          <div
            key={key}
            style={{
              background: '#fff',
              border: '2px solid #ddd',
              borderRadius: '8px',
              padding: '1.5rem',
              cursor: 'pointer',
              transition: 'all 0.3s ease',
              textAlign: 'center'
            }}
            onClick={() => onSelectLevel(key)}
            onMouseEnter={(e) => {
              e.target.style.borderColor = '#007bff';
              e.target.style.transform = 'translateY(-2px)';
              e.target.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
            }}
            onMouseLeave={(e) => {
              e.target.style.borderColor = '#ddd';
              e.target.style.transform = 'translateY(0)';
              e.target.style.boxShadow = 'none';
            }}
          >
            <h2 style={{ margin: '0 0 0.5rem 0', color: '#333' }}>{level.name}</h2>
            <p style={{ margin: '0 0 1rem 0', color: '#666', fontWeight: 'bold' }}>{level.description}</p>
            <p style={{ margin: 0, color: '#888', fontSize: '0.9rem' }}>{level.details}</p>
          </div>
        ))}
      </div>
    </div>
  );
}

// Arrow component for pointing to 3D elements
function Arrow3D({ fromX, fromY, toX, toY, color = '#007bff' }) {
  const arrowLength = Math.sqrt(Math.pow(toX - fromX, 2) + Math.pow(toY - fromY, 2));
  const angle = Math.atan2(toY - fromY, toX - fromX) * 180 / Math.PI;
  
  return (
    <div
      style={{
        position: 'absolute',
        left: fromX,
        top: fromY,
        width: arrowLength,
        height: '2px',
        backgroundColor: color,
        transformOrigin: '0 50%',
        transform: `rotate(${angle}deg)`,
        zIndex: 11,
        pointerEvents: 'none'
      }}
    >
      {/* Arrow head */}
      <div
        style={{
          position: 'absolute',
          right: '-8px',
          top: '-4px',
          width: '0',
          height: '0',
          borderLeft: '8px solid ' + color,
          borderTop: '4px solid transparent',
          borderBottom: '4px solid transparent'
        }}
      />
    </div>
  );
}

// Introduction Tutorial Component
function IntroductionTutorial({ onNext, onBack, currentStep, onDepositCopper }) {
  const steps = [
    {
      title: "Welcome to Cool Fab Games",
      content: (
        <div>
          This is a nano-fabrication simulator, where you'll get to build the devices that enable our digital world, using real processing steps.c/pe
          Let's start by exploring the basic building blocks...
        </div>
      ),
      arrows: [
        { target: "top-silicon", text: "Silicon is the basic building block of these devices", position: "top" },
        { target: "substrate", text: "It's very regular crystal form makes it excellent at controlling electricity", position: "bottom" },
        { target: "substrate", text: "But for now, it'll just be grey", position: "bottom" }
      ],
      arrowTargets: [
        { fromPercent: { x: 90, y: 30 }, toPercent: { x: 55, y: 20 }, color: '#007bff' }, // Point to top silicon
        { fromPercent: { x: 90, y: 60 }, toPercent: { x: 55, y: 40 }, color: '#007bff' }  // Point to substrate
      ]
    },
    {
      title: "The Buried Oxide Layer",
      content: (
        <div>
          cpeThis blue layer is silicon dioxide (SiO₂), also called silicon oxide.c/pe
          cpeIt acts as an insulator between the silicon layers.c/pe
          cpeThis structure is called Silicon-On-Insulator (SOI) and is commonly used in modern chips.c/pe
        </div>
      ),
      arrows: [
        { target: "buried-oxide", text: "This buried oxide layer provides electrical isolation", position: "right" }
      ],
      arrowTargets: [
        { fromPercent: { x: 90, y: 50 }, toPercent: { x: 55, y: 30 }, color: '#8ac6d1' } // Point to buried oxide
      ]
    },
    {
      title: "Depositing Copper",
      content: (
        cdive
          cpeNow let's add our first metal layer - copper!c/pe
          cpeCopper deposition is typically done using physical vapor deposition (PVD) or electroplating.c/pe
          cpeThe copper atoms are deposited uniformly across the entire surface, forming a thin conductive layer.c/pe
          cpecstrongeTry it:c/stronge Click the "Deposit Cu" button to add a copper layer!c/pe
        c/dive
      ),
      arrows: [
        { target: "copper-button", text: "Click this button to deposit copper", position: "left" }
      ],
      arrowTargets: [
        { fromPercent: { x: 85, y: 50 }, toPercent: { x: 92, y: 45 }, color: '#f6d186' } // Point to copper button
      ],
      interactive: true
    }
  ];

  const currentStepData = steps[currentStep] || steps[0];

  return (
    <div style={{
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center',
      height: '100vh',
      width: '100vw',
      background: '#f0f0f0'
    }}>
      cdiv style={{
        display: 'grid',
        gridTemplateRows: '1fr 2fr',
        gridTemplateColumns: '1fr 2fr',
        width: '80%', height: '80%',
        maxWidth: 1200, maxHeight: 800,
        background: '#fff',
        boxShadow: '0 4px 10px rgba(0,0,0,0.1)',
        position: 'relative'
      }}e
        {currentStep === 2 && (
          cbutton 
            onClick={onDepositCopper}
            style={{
              position: 'absolute',
              right: '40px',
              bottom: '40px',
              padding: '8px 16px',
              background: '#f6d186',
              border: 'none',
              borderRadius: '8px',
              color: 'white',
              cursor: 'pointer',
              zIndex: 12
            }}
          eDeposit Cuc/buttone
        )}
        {/* Tutorial Info Panel */}
        <div style={{ gridRow: '1/2', gridColumn: '1/2', background: '#f4f4f4', padding: 20 }}>
          <h3>{currentStepData.title}</h3>
          {currentStepData.content}
          <div style={{ marginTop: 20, display: 'flex', gap: 10 }}>
            <button 
              onClick={onBack}
              style={{ 
                padding: '8px 16px', 
                border: 'none', 
                borderRadius: '4px', 
                background: '#6c757d', 
                color: 'white', 
                cursor: 'pointer' 
              }}
            >
              ← Back to Level Select
            </button>
            <button 
              onClick={onNext}
              style={{ 
                padding: '8px 16px', 
                border: 'none', 
                borderRadius: '4px', 
                background: '#007bff', 
                color: 'white', 
                cursor: 'pointer' 
              }}
            >
              {currentStep < steps.length - 1 ? 'Next →' : 'Finish'}
            </button>
          </div>
        </div>

        {/* Additional explanation area */}
        <div style={{
          gridRow: '2/3',
          gridColumn: '1/2',
          background: '#f4f4f4',
          padding: 20,
          display: 'flex',
          flexDirection: 'column',
          justifyContent: 'center'
        }}>
          {currentStepData.arrows.map((arrow, index) => (
            <div key={index} style={{ marginBottom: 15, padding: 10, background: '#fff', borderRadius: 4, border: '1px solid #ddd' }}>
              <p style={{ margin: 0, fontWeight: 'bold' }}>→ {arrow.text}</p>
            </div>
          ))}
        </div>

        {/* 3D View - Show substrate only */}
        <div style={{ gridRow:'1/3',gridColumn:'2/3', position: 'relative' }}>
          <Canvas
            style={{ width:'100%',height:'100%' }}
            camera={{ position:[30, 20, 30], fov:45 }}
          >
            <ambientLight intensity={0.5} />
            <directionalLight position={[-15, 15, 5]} intensity={1} />

            {/* Render substrate layers */}
            {Array.from({ length: 5 }, (_, z) => {
              const cubes = [];
              for (let x = 0; x < GRID_SIZE; x++) {
                for (let y = 0; y < GRID_SIZE; y++) {
                  // pick SOI material
                  const isOxide = (z === 2 || z === 3);
                  const isTopSilicon = (z === 4);
                  const mat = isOxide
                    ? MATERIALS.SILICON_OXIDE
                    : MATERIALS.SUBSTRATE;

                  const worldX = x - GRID_SIZE/2 + 0.5;
                  const worldY = z + 0.5;
                  const worldZ = y - GRID_SIZE/2 + 0.5;
                  
                  // Highlight based on current step
                  let shouldHighlight = false;
                  if (currentStep === 0 && (isTopSilicon || (!isOxide && !isTopSilicon))) {
                    shouldHighlight = true;
                  } else if (currentStep === 1 && isOxide) {
                    shouldHighlight = true;
                  }
                  
                  cubes.push(
                    <mesh 
                      key={`substrate-${x}-${y}-${z}`} 
                      position={[worldX, worldY, worldZ]}
                    >
                      <boxGeometry args={[CUBE_SIZE, CUBE_SIZE, CUBE_SIZE]} />
                      <meshPhysicalMaterial
                        color={mat.color}
                        transparent={isOxide}
                        opacity={isOxide ? MATERIALS.SILICON_OXIDE.transparency : 1}
                        ior={1}
                        emissive={shouldHighlight ? '#444' : '#000'}
                        emissiveIntensity={shouldHighlight ? 0.2 : 0}
                      />
                    </mesh>
                  );
                }
              }
              return cubes;
            })}

            <OrbitControls />
          </Canvas>
        </div>
      </div>
    </div>
  );
}

function PhotomaskEditor({ photomask, onSave, onCancel, goalRects }) {
  const maskRef = useRef(null);
  const goalRef = useRef(null);

  // Mask editor state
  const [isDragging, setIsDragging] = useState(false);
  const [dragStart, setDragStart] = useState(null);
  const [dragEnd, setDragEnd] = useState(null);
  const [dragMode, setDragMode] = useState(null);
  const [mouseDownPos, setMouseDownPos] = useState(null);
  const [hasMoved, setHasMoved] = useState(false);
  const [maskCells, setMaskCells] = useState(
    () => Array.from({ length: 20 }, () => Array(20).fill(false))
  );

  // Decode existing photomask URL into maskCells when opening editor
  useEffect(() => {
    if (!photomask) return;
    const img = new Image();
    img.crossOrigin = 'Anonymous';
    img.src = photomask;
    img.onload = () => {
      const size = 200;
      const off = document.createElement('canvas');
      off.width = off.height = size;
      const ctx = off.getContext('2d');
      ctx.drawImage(img, 0, 0, size, size);

      const grid = 20;
      const cell = size / grid;
      const newCells = Array.from({ length: grid }, () => Array(grid).fill(false));

      for (let r = 0; r < grid; r++) {
        for (let c = 0; c < grid; c++) {
          const p = ctx.getImageData(c * cell + cell / 2, r * cell + cell / 2, 1, 1).data;
          if (p[0] < 128) newCells[r][c] = true;
        }
      }
      setMaskCells(newCells);
    };
  }, [photomask]);

  // Utility to draw grid
  const drawGrid = (ctx, size) => {
    const cell = size / 20;
    ctx.clearRect(0, 0, size, size);
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, size, size);
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 1;
    for (let i = 0; i <= 20; i++) {
      const p = i * cell;
      ctx.beginPath(); ctx.moveTo(p, 0); ctx.lineTo(p, size); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0, p); ctx.lineTo(size, p); ctx.stroke();
    }
  };

  // Utility to draw mask cells
  const drawCells = (ctx, cells, size) => {
    const cell = size / 20;
    ctx.fillStyle = '#000';
    cells.forEach((row, r) =>
      row.forEach((filled, c) => {
        if (filled) ctx.fillRect(c * cell, r * cell, cell, cell);
      })
    );

    // Drag preview
    if (isDragging && dragStart && dragEnd) {
      ctx.fillStyle = dragMode === 'add' ? 'rgba(0,0,0,0.3)' : 'rgba(255,255,255,0.8)';
      const minC = Math.min(dragStart.c, dragEnd.c);
      const maxC = Math.max(dragStart.c, dragEnd.c);
      const minR = Math.min(dragStart.r, dragEnd.r);
      const maxR = Math.max(dragStart.r, dragEnd.r);
      for (let r = minR; r <= maxR; r++) {
        for (let c = minC; c <= maxC; c++) {
          ctx.fillRect(c * cell, r * cell, cell, cell);
        }
      }
      ctx.strokeStyle = '#f00';
      ctx.lineWidth = 2;
      ctx.strokeRect(
        minC * cell,
        minR * cell,
        (maxC - minC + 1) * cell,
        (maxR - minR + 1) * cell
      );
    }
  };

  const getCellFromEvent = e => {
    const canvas = maskRef.current;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const cell = canvas.width / 20;
    return { c: Math.floor(x / cell), r: Math.floor(y / cell) };
  };

  // Mask drawing effect
  useEffect(() => {
    if (!maskRef.current) return;
    const ctx = maskRef.current.getContext('2d');
    const size = maskRef.current.width;
    drawGrid(ctx, size);
    drawCells(ctx, maskCells, size);
  }, [maskCells, isDragging, dragStart, dragEnd, dragMode]);

  // Goal drawing effect
  useEffect(() => {
    if (!goalRef.current) return;
    const ctx = goalRef.current.getContext('2d');
    const size = goalRef.current.width;
    drawGrid(ctx, size);
    goalRects.forEach(r => {
      ctx.fillStyle = r.color;
      ctx.fillRect(r.x * size, r.y * size, r.w * size, r.h * size);
    });
  }, [goalRects]);

  // Event handlers
  const handleMouseDown = e => {
    const { c, r } = getCellFromEvent(e);
    if (c < 0 || c >= 20 || r < 0 || r >= 20) return;
    setIsDragging(true);
    setDragStart({ c, r });
    setDragEnd({ c, r });
    setMouseDownPos({ c, r });
    setHasMoved(false);
    setDragMode(maskCells[r][c] ? 'remove' : 'add');
  };

  const handleMouseMove = e => {
    if (!isDragging) return;
    const { c, r } = getCellFromEvent(e);
    if (c < 0 || c >= 20 || r < 0 || r >= 20) return;
    if (mouseDownPos && (c !== mouseDownPos.c || r !== mouseDownPos.r)) setHasMoved(true);
    setDragEnd({ c, r });
  };

  const handleMouseUp = e => {
    if (!isDragging) return;
    const { c, r } = getCellFromEvent(e);
    const newCells = maskCells.map(row => row.slice());
    if (!hasMoved && mouseDownPos && c === mouseDownPos.c && r === mouseDownPos.r) {
      newCells[r][c] = !newCells[r][c];
    } else {
      const minC = Math.min(dragStart.c, c);
      const maxC = Math.max(dragStart.c, c);
      const minR = Math.min(dragStart.r, r);
      const maxR = Math.max(dragStart.r, r);
      for (let rr = minR; rr <= maxR; rr++) {
        for (let cc = minC; cc <= maxC; cc++) {
          newCells[rr][cc] = dragMode === 'add';
        }
      }
    }
    setMaskCells(newCells);
    setIsDragging(false);
    setDragStart(null);
    setDragEnd(null);
    setDragMode(null);
    setMouseDownPos(null);
    setHasMoved(false);
  };

  const handleClick = e => e.preventDefault();

  const handleSave = () => {
    const canvas = maskRef.current;
    onSave(canvas.toDataURL());
  };

  const handleReset = () => setMaskCells(Array.from({ length: 20 }, () => Array(20).fill(false)));
  const handleInvert = () => setMaskCells(maskCells.map(row => row.map(cell => !cell)));

  return (
    <div style={{ display: 'flex', background: '#fff', padding: 20, borderRadius: 8, boxShadow: '0 4px 12px rgba(0,0,0,0.2)', gap: 20 }}>
      {/* Goal view */}
      <div>
        <h3 style={{ margin: '0 0 10px' }}>Goal</h3>
        <canvas ref={goalRef} width={200} height={200} style={{ border: '1px solid #000' }} />
      </div>

      {/* Mask editor view */}
      <div>
        <h3 style={{ margin: '0 0 10px' }}>Photomask Editor</h3>
        <canvas
          ref={maskRef}
          width={400}
          height={400}
          style={{ border: '1px solid #000', cursor: 'pointer' }}
          onMouseDown={handleMouseDown}
          onMouseMove={handleMouseMove}
          onMouseUp={handleMouseUp}
          onClick={handleClick}
        />
        <div style={{ marginTop: 10, display: 'flex', gap: 10 }}>
          <button onClick={handleSave}>Save Mask</button>
          <button onClick={handleReset}>Reset</button>
          <button onClick={handleInvert}>Invert</button>
          <button onClick={onCancel}>Cancel</button>
        </div>
      </div>
    </div>
  );
}


// refactor everything to be squares, not layers and rectangles
// Cube-based fabrication constants
const GRID_SIZE = 20; // 20x20 grid
const MAX_HEIGHT = 30; // Maximum height in cube layers
const CUBE_SIZE = 1; // Each cube is 1x1x1 unit

// Material types and colors
const MATERIALS = {
  EMPTY: { color: null, name: 'Empty' },
  SUBSTRATE: { color: '#c0c0c0', name: 'Silicon Substrate' },
  COPPER: { color: '#f6d186', name: 'Copper' },
  SILICON_OXIDE: { color: '#8ac6d1', name: 'Silicon Oxide', transparency: 0.08},
  AMORPHOUS_SILICON: { color: 'grey', name: 'Amorphous Silicon' },
  PHOTORESIST: { color: 'green', name: 'Photoresist' }
};

export default function FabSimulator() {
  const [currentLevel, setCurrentLevel] = useState(null);
  
  // NEW: 3D cube grid - [x][y][z] where z=0 is bottom
  const [cubeGrid, setCubeGrid] = useState(() => {
    // Initialize with substrate at bottom layers
    const grid = Array(GRID_SIZE).fill(null).map(() => 
      Array(GRID_SIZE).fill(null).map(() => 
        Array(MAX_HEIGHT).fill(MATERIALS.EMPTY)
      )
    );
    
  // New: Silicon-On-Insulator (SOI) substrate
  for (let x = 0; x < GRID_SIZE; x++) {
    for (let y = 0; y < GRID_SIZE; y++) {
      grid[x][y][0] = MATERIALS.SUBSTRATE;       // Bottom silicon
      grid[x][y][1] = MATERIALS.SUBSTRATE;       // Second silicon layer
      grid[x][y][2] = MATERIALS.SILICON_OXIDE;   // Buried oxide layer (BOX)
      grid[x][y][3] = MATERIALS.SILICON_OXIDE;   // Buried oxide layer (BOX)
      grid[x][y][4] = MATERIALS.SUBSTRATE;       // Top silicon device layer
    }
  }
    
    return grid;
  });
  
  const [photomask, setPhotomask] = useState(null);
  const [editingMask, setEditingMask] = useState(false);
  const [goalRects, setGoalRects] = useState([]); // Will be set based on selected level
  
  // slider state for clipping plane - MUST be before conditional returns
  const [slicePosition, setSlicePosition] = useState(1);
  // At the top of your FabSimulator component, after your diffCount calculation:
  const [completed, setCompleted] = useState(false);
  
  // Introduction tutorial state
  const [tutorialStep, setTutorialStep] = useState(0);



    // at top of FabSimulator(), after your other hooks…
  const diffCount = useMemo(() => {
    // build a boolean goal‐grid [x][y][z]
    const goalGrid = Array(GRID_SIZE).fill(null).map(() =>
      Array(GRID_SIZE).fill(null).map(() =>
        Array(MAX_HEIGHT).fill(false)
      )
    );

    // mark all the goal cubes from goalRects
    goalRects.forEach(r => {
      const startX = Math.floor(r.x * GRID_SIZE);
      const endX   = Math.floor((r.x + r.w) * GRID_SIZE);
      const startY = Math.floor(r.y * GRID_SIZE);
      const endY   = Math.floor((r.y + r.h) * GRID_SIZE);
      const z      = r.l - 1 + 5;   // offset by your 5-layer substrate

      for (let x = startX; x < endX; x++) {
        for (let y = startY; y < endY; y++) {
          if (
            x >= 0 && x < GRID_SIZE &&
            y >= 0 && y < GRID_SIZE &&
            z >= 0 && z < MAX_HEIGHT
          ) {
            goalGrid[x][y][z] = true;
          }
        }
      }
    });

    // compare user vs goal (ignore z < 5 since that's your fixed substrate)
    let count = 0;
    for (let x = 0; x < GRID_SIZE; x++) {
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let z = 5; z < MAX_HEIGHT; z++) {
          const userHas = cubeGrid[x][y][z] !== MATERIALS.EMPTY;
          const goalHas = goalGrid[x][y][z];
          if (userHas !== goalHas) count++;
        }
      }
    }
    return count;
  }, [cubeGrid, goalRects]);

  useEffect(() => {
    setCompleted(diffCount === 0);
    }, [diffCount]);
  
  // Utility functions for cube operations
  const getTopCubeHeight = (x, y, grid = cubeGrid) => {
    for (let z = MAX_HEIGHT - 1; z >= 0; z--) {
      if (grid[x][y][z] !== MATERIALS.EMPTY) {
        return z;
      }
    }
    return -1; // No cubes at this position
  };
  
  const depositMaterial = (material, maskPattern = null) => {
    setCubeGrid(prevGrid => {
      const newGrid = prevGrid.map(xArray => 
        xArray.map(yArray => [...yArray])
      );
      
      for (let x = 0; x < GRID_SIZE; x++) {
        for (let y = 0; y < GRID_SIZE; y++) {
          // Check if we should deposit here (either no mask or mask allows it)
          const shouldDeposit = !maskPattern || maskPattern[y][x];
          
          if (shouldDeposit) {
            const topHeight = getTopCubeHeight(x, y, prevGrid);
            const newHeight = topHeight + 1;
            
            if (newHeight < MAX_HEIGHT) {
              newGrid[x][y][newHeight] = material;
            }
          }
        }
      }
      
      return newGrid;
    });
  };
  
  const etchTopLayer = (maskPattern = null) => {
    setCubeGrid(prevGrid => {
      const newGrid = prevGrid.map(xArray => 
        xArray.map(yArray => [...yArray])
      );
      
      for (let x = 0; x < GRID_SIZE; x++) {
        for (let y = 0; y < GRID_SIZE; y++) {
          // Check if we should etch here (either no mask or mask allows it)
          const shouldEtch = !maskPattern || maskPattern[y][x];
          
          if (shouldEtch) {
            const topHeight = getTopCubeHeight(x, y, prevGrid);
            if (topHeight > 0) { // Don't etch substrate
              newGrid[x][y][topHeight] = MATERIALS.EMPTY;
            }
          }
        }
      }
      
      return newGrid;
    });
  };
  
  // Convert photomask to boolean pattern for deposition/etching
  const getMaskPattern = async (photomaskUrl) => {
    if (!photomaskUrl) return null;
    
    const img = new Image();
    img.crossOrigin = 'Anonymous';
    img.src = photomaskUrl;
    await new Promise(res => img.onload = res);
    
    const size = 200;
    const canvas = document.createElement('canvas');
    canvas.width = canvas.height = size;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0, size, size);
    
    const pattern = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(false));
    const cellSize = size / GRID_SIZE;
    
    for (let y = 0; y < GRID_SIZE; y++) {
      for (let x = 0; x < GRID_SIZE; x++) {
        const pixelData = ctx.getImageData(x * cellSize + cellSize/2, y * cellSize + cellSize/2, 1, 1).data;
        pattern[y][x] = pixelData[0] < 128; // Black areas are true
      }
    }
    
    return pattern;
  };
  
  // Convert slider position to discrete x-coordinate for cube filtering
  const sliceX = Math.floor(slicePosition * GRID_SIZE);

  // Handle level selection
  const handleSelectLevel = (levelKey) => {
    setCurrentLevel(levelKey);
    const level = LEVELS[levelKey];
    if (level) {
      setGoalRects(level.goalRects);
    }
  };

  // Show level select screen if no level is selected
  if (!currentLevel) {
    return <LevelSelect onSelectLevel={handleSelectLevel} />;
  }

  const currentLevelData = LEVELS[currentLevel];
  if (!currentLevelData) {
    return <LevelSelect onSelectLevel={handleSelectLevel} />;
  }
  
  // These old functions are no longer needed with the cube system

  const handleDeposit_Cu = () => {
    depositMaterial(MATERIALS.COPPER);
  };

  const handleDeposit_SiO2 = () => {
    depositMaterial(MATERIALS.SILICON_OXIDE);
  };

  const handleDeposit_aSi = () => {
    depositMaterial(MATERIALS.AMORPHOUS_SILICON);
  };

  const handleSpin = () => {
    // Spin photoresist - deposits a layer of photoresist over entire surface
    depositMaterial(MATERIALS.PHOTORESIST);
  };


  const handlePlasmaClean = () => {
    // Liftoff process: Remove photoresist and any material deposited on top of it
    setCubeGrid(prevGrid => {
      const newGrid = prevGrid.map(xArray => 
        xArray.map(yArray => [...yArray])
      );
      
      for (let x = 0; x < GRID_SIZE; x++) {
        for (let y = 0; y < GRID_SIZE; y++) {
          // Find all photoresist layers at this position
          for (let z = 0; z < MAX_HEIGHT; z++) {
            if (newGrid[x][y][z] === MATERIALS.PHOTORESIST) {
              // Remove the photoresist
              newGrid[x][y][z] = MATERIALS.EMPTY;
              
              // Remove everything above this photoresist layer (liftoff)
              for (let zAbove = z + 1; zAbove < MAX_HEIGHT; zAbove++) {
                if (newGrid[x][y][zAbove] !== MATERIALS.EMPTY) {
                  newGrid[x][y][zAbove] = MATERIALS.EMPTY;
                }
              }
            }
          }
        }
      }
      
      return newGrid;
    });
  };

  const handleExposeDevelop = async () => {
    if (!photomask) return;
    
    // Get mask pattern and remove photoresist where exposed (black areas)
    const maskPattern = await getMaskPattern(photomask);
    if (!maskPattern) return;
    
    setCubeGrid(prevGrid => {
      const newGrid = prevGrid.map(xArray => 
        xArray.map(yArray => [...yArray])
      );
      
      for (let x = 0; x < GRID_SIZE; x++) {
        for (let y = 0; y < GRID_SIZE; y++) {
          // If mask is true (black area), remove photoresist
          if (maskPattern[y][x]) {
            for (let z = 0; z < MAX_HEIGHT; z++) {
              if (newGrid[x][y][z] === MATERIALS.PHOTORESIST) {
                newGrid[x][y][z] = MATERIALS.EMPTY;
              }
            }
          }
        }
      }
      
      return newGrid;
    });
  };

  const handleEtch = () => {
    // Etch top layer where not protected by photoresist
    setCubeGrid(prevGrid => {
      const newGrid = prevGrid.map(xArray => 
        xArray.map(yArray => [...yArray])
      );
      
      for (let x = 0; x < GRID_SIZE; x++) {
        for (let y = 0; y < GRID_SIZE; y++) {
          const topHeight = getTopCubeHeight(x, y, prevGrid);
          
          if (topHeight > 0) { // Don't etch substrate
            // Check if this position is protected by photoresist
            let isProtected = false;
            for (let z = topHeight + 1; z < MAX_HEIGHT; z++) {
              if (newGrid[x][y][z] === MATERIALS.PHOTORESIST) {
                isProtected = true;
                break;
              }
            }
            
            // If not protected, etch the top cube
            if (!isProtected) {
              newGrid[x][y][topHeight] = MATERIALS.EMPTY;
            }
          }
        }
      }
      
      return newGrid;
    });
  };

  const handleCMP = () => {
    // Chemical Mechanical Planarization - flatten the surface
    setCubeGrid(prevGrid => {
      // Find the lowest height across all positions
      let minHeight = MAX_HEIGHT;
      
      // Find the minimum height across the surface
      for (let x = 0; x < GRID_SIZE; x++) {
        for (let y = 0; y < GRID_SIZE; y++) {
          const topHeight = getTopCubeHeight(x, y, prevGrid);
          if (topHeight < minHeight) {
            minHeight = topHeight;
          }
        }
      }
      
      // Remove everything above the minimum height to create a flat surface
      const newGrid = prevGrid.map(xArray => 
        xArray.map(yArray => [...yArray])
      );
      
      for (let x = 0; x < GRID_SIZE; x++) {
        for (let y = 0; y < GRID_SIZE; y++) {
          for (let z = minHeight + 1; z < MAX_HEIGHT; z++) {
            newGrid[x][y][z] = MATERIALS.EMPTY;
          }
        }
      }
      
      return newGrid;
    });
  };



  const openMaskEditor = () => setEditingMask(true);
  const saveMask = (m) => { setPhotomask(m); setEditingMask(false); };
  const cancelMask = () => setEditingMask(false);
  
  // Tutorial handlers
  const handleTutorialNext = () => {
    const totalSteps = 3; // Total number of tutorial steps
    if (tutorialStep < totalSteps - 1) {
      setTutorialStep(tutorialStep + 1);
    } else {
      // Tutorial finished, go back to level select
      setCurrentLevel(null);
      setTutorialStep(0);
    }
  };
  
  const handleTutorialDepositCopper = () => {
    handleDeposit_Cu();
    // Auto-advance to next step after copper deposition
    setTimeout(() => {
      handleTutorialNext();
    }, 500);
  };
  
  const handleTutorialBack = () => {
    setCurrentLevel(null);
    setTutorialStep(0);
  };

  if (editingMask) {
    return (
      <div
        style={{
          position: 'fixed',
          top: 0, left: 0,
          width: '100vw', height: '100vh',
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          zIndex: 999
        }}
      >
        <PhotomaskEditor
          photomask={photomask}
          onSave={saveMask}
          onCancel={cancelMask}
          goalRects={goalRects}
        />
      </div>
    );
  }

  // Show tutorial for introduction level
  if (currentLevel === 'introduction') {
    return (
      <div style={{ position: 'relative', width: '100vw', height: '100vh' }}>
        <IntroductionTutorial 
          onNext={handleTutorialNext}
          onBack={handleTutorialBack}
          currentStep={tutorialStep}
          onDepositCopper={handleTutorialDepositCopper}
        />
        {/* Render arrows for current step */}
        {(() => {
          const steps = [
            {
              arrowTargets: [
                { fromPercent: { x: 90, y: 30 }, toPercent: { x: 55, y: 20 }, color: '#007bff' }, // Point to top silicon
                { fromPercent: { x: 90, y: 60 }, toPercent: { x: 55, y: 40 }, color: '#007bff' }  // Point to substrate
              ]
            },
            {
              arrowTargets: [
                { fromPercent: { x: 90, y: 50 }, toPercent: { x: 55, y: 30 }, color: '#8ac6d1' } // Point to buried oxide
              ]
            },
            {
              arrowTargets: [
                { fromPercent: { x: 85, y: 80 }, toPercent: { x: 92, y: 85 }, color: '#f6d186' } // Point to copper button
              ]
            }
          ];
          
          const currentStepData = steps[tutorialStep] || steps[0];
          
          return currentStepData.arrowTargets?.map((arrow, index) => (
            <Arrow3D
              key={index}
              fromX={window.innerWidth * arrow.fromPercent.x / 100}
              fromY={window.innerHeight * arrow.fromPercent.y / 100}
              toX={window.innerWidth * arrow.toPercent.x / 100}
              toY={window.innerHeight * arrow.toPercent.y / 100}
              color={arrow.color}
            />
          ));
        })()}
      </div>
    );
  }

  return (
    <div style={{
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center',
      height: '100vh',
      width: '100vw',
      background: '#f0f0f0'
    }}>
      <div style={{
        display: 'grid',
        gridTemplateRows: '1fr 2fr',
        gridTemplateColumns: '1fr 2fr 200px',
        width: '80%', height: '80%',
        maxWidth: 1200, maxHeight: 800,
        background: '#fff',
        boxShadow: '0 4px 10px rgba(0,0,0,0.1)'
      }}>
        {/* Level Info Panel */}
        <div style={{ gridRow: '1/2', gridColumn: '1/2', background: '#f4f4f4' }}>
          <h3 style={{paddingLeft: 10}}>Build a {currentLevelData.name}</h3>
          <p style={{paddingLeft: 10}}>{currentLevelData.description}</p>
          <p style={{paddingLeft: 10}}>{currentLevelData.details}</p>
          <button 
            onClick={() => setCurrentLevel(null)} 
            style={{ 
              margin: '10px', 
              padding: '8px 16px', 
              border: 'none', 
              borderRadius: '4px', 
              background: '#007bff', 
              color: 'white', 
              cursor: 'pointer' 
            }}
          >
            ← Back to Level Select
          </button>
        </div>

        {/* 3D Goal with Clipping Slider */}
        <div style={{
          gridRow: '2/3',
          gridColumn: '1/2',
          background: '#f4f4f4',
          position: 'relative',
          width: '100%',
          height: '100%'
        }}>
          <Canvas
            style={{ width: '100%', height: 'calc(100% - 40px)' }}
            camera={{ position: [30, 20, 30], fov: 45 }}
          >
            <ambientLight intensity={0.5} />
            <directionalLight position={[-15, 15, 5]} intensity={1} />

            {/* Render substrate layers for goal as individual cubes */}
            {Array.from({ length: 5 }, (_, z) => {
              const cubes = [];
              for (let x = 0; x < GRID_SIZE; x++) {
                for (let y = 0; y < GRID_SIZE; y++) {
                  if (x > sliceX) continue;

                  // pick SOI material
                  const isOxide = (z === 2 || z === 3);
                  const mat = isOxide
                    ? MATERIALS.SILICON_OXIDE
                    : MATERIALS.SUBSTRATE;

                  const worldX = x - GRID_SIZE/2 + 0.5;
                  const worldY = z + 0.5;
                  const worldZ = y - GRID_SIZE/2 + 0.5;
                  
                  cubes.push(
                    <mesh key={`goal-substrate-${x}-${y}-${z}`} position={[worldX, worldY, worldZ]}>
                      <boxGeometry args={[CUBE_SIZE, CUBE_SIZE, CUBE_SIZE]} />
                      <meshPhysicalMaterial
                          color={mat.color}
                          transparent={isOxide}
                          opacity={isOxide ? MATERIALS.SILICON_OXIDE.transparency : 1}
                          ior={1}
                        />
                    </mesh>
                  );
                }
              }
              return cubes;
            })}

            {/* Render goal structure as cubes */}
            {goalRects.map((r,i) => {
              // Convert old rect format to cube positions
              const startX = Math.floor(r.x * GRID_SIZE);
              const endX = Math.floor((r.x + r.w) * GRID_SIZE);
              const startY = Math.floor(r.y * GRID_SIZE);
              const endY = Math.floor((r.y + r.h) * GRID_SIZE);
              const z = r.l - 1 + 5; // Convert 1-based layer to 0-based z, offset by 5 for substrate
              
              const cubes = [];
              for (let x = startX; x < endX; x++) {
                for (let y = startY; y < endY; y++) {
                  // Only render cubes at or below the slice position
                  if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE && z >= 0 && z < MAX_HEIGHT && x <= sliceX) {
                    const worldX = x - GRID_SIZE/2 + 0.5;
                    const worldY = z + 0.5;
                    const worldZ = y - GRID_SIZE/2 + 0.5;
                    
                    cubes.push(
                      <mesh 
                        key={`goal-${i}-${x}-${y}-${z}`} 
                        position={[worldX, worldY, worldZ]}
                      >
                        <boxGeometry args={[CUBE_SIZE, CUBE_SIZE, CUBE_SIZE]} />
                        <meshStandardMaterial
                          color={r.color}
                          transparent={r.color === MATERIALS.SILICON_OXIDE.color} // only SiO₂ is transparent
                          opacity={r.color === MATERIALS.SILICON_OXIDE.color ? MATERIALS.SILICON_OXIDE.transparency : 1}
                        />
                        {/*<Edges color="black" lineWidth={1} /> */}
                      </mesh>
                    );
                  }
                }
              }
              return cubes;
            })}

            <OrbitControls />
          </Canvas>

          <input
            type="range"
            min={0} max={1} step={0.01}
            value={slicePosition}
            onChange={e => setSlicePosition(parseFloat(e.target.value))}
            style={{
              position: 'absolute',
              bottom: 10,
              left: '5%',
              width: '90%'
            }}
          />
        </div>

        {completed && (
          <div style={{
            position: 'absolute',
            top: '10%',
            left: '50%',
            transform: 'translateX(-50%)',
            fontSize: '3rem',
            color: '#28a745',
            zIndex: 10,
            pointerEvents: 'none',
          }}>
            Completed!
          </div>
        )}

        {completed && <Confetti />}


        {/* 3D View - Cube-based rendering */}
        <div style={{ gridRow:'1/3',gridColumn:'2/3' }}>
          <Canvas
            style={{ width:'100%',height:'100%' }}
            camera={{ position:[30, 20, 30], fov:45 }}
          >
            <ambientLight intensity={0.5} />
            <directionalLight position={[-15, 15, 5]} intensity={1} />

            {/* Render all cubes */}
            {cubeGrid.map((xArray, x) =>
              xArray.map((yArray, y) =>
                yArray.map((cube, z) => {
                  // Only render cubes at or below the slice position
                  if (cube === MATERIALS.EMPTY || x > sliceX) return null;
                  
                  const worldX = x - GRID_SIZE/2 + 0.5;
                  const worldY = z + 0.5;
                  const worldZ = y - GRID_SIZE/2 + 0.5;
                  
                  return (
                    <mesh 
                      key={`${x}-${y}-${z}`} 
                      position={[worldX, worldY, worldZ]}
                    >
                      <boxGeometry args={[CUBE_SIZE, CUBE_SIZE, CUBE_SIZE]} />
                      <meshStandardMaterial
                        color={cube.color}
                        transparent={cube === MATERIALS.SILICON_OXIDE} // only SiO₂ is transparent

                        opacity={cube === MATERIALS.SILICON_OXIDE ? MATERIALS.SILICON_OXIDE.transparency : 1}
                      />
                      {/*{cube !== MATERIALS.SUBSTRATE && <Edges color="black" lineWidth={1} />}*/}
                    </mesh>
                  );
                })
              )
            )}


            <OrbitControls />
          </Canvas>
        </div>

        {/* Controls */}
        <div style={{
          gridRow: '1/3',
          gridColumn: '3/4',
          padding: 20,
          background: '#f4f4f4',
          display:'flex',
          flexDirection:'column',
          justifyContent:'center'
        }}>
          <button onClick={handleDeposit_Cu} style={{marginBottom:10}}>Deposit Cu</button>
          <button onClick={handleDeposit_SiO2} style={{marginBottom:10}}>Deposit SiO₂</button>
          <button onClick={handleDeposit_aSi} style={{marginBottom:10}}>Deposit aSi</button>
          <button onClick={handlePlasmaClean} style={{marginBottom:10}}>Plasma Clean</button>
          <button onClick={handleSpin} style={{marginBottom:10}}>Spin Photoresist</button>
          <button onClick={handleExposeDevelop} style={{marginBottom:10}}>Expose & Develop</button>
          <button onClick={handleEtch} style={{marginBottom:10}}>Dry Etch</button>
          <button onClick={handleCMP} style={{marginBottom:10}}>CMP</button>
          <button onClick={openMaskEditor} style={{height:140,marginBottom:10,position:'relative'}}>
            {photomask
              ? <img src={photomask} alt="Mask" style={{height:'100%',objectFit:'cover'}}/>
              : <span style={{position:'absolute',top:'50%',left:'50%',transform:'translate(-50%, -50%)'}}>Edit Mask</span>
            }
          </button>
          <p>{diffCount} blocks away</p>
        </div>
      </div>
    </div>
  );
}
